import { AfterViewInit, Component, Input, SimpleChanges } from '@angular/core';
import { ApiService } from '../services/api.service'
import { TileUrl } from '../interfaces/tileurls.interface'

import * as L from 'leaflet';
import { Mill } from '../interfaces/mill.interface';

@Component({
  selector: 'app-map',
  templateUrl: './map.component.html',
  styleUrls: ['./map.component.css']
})
export class MapComponent implements AfterViewInit  {
  readonly attribution = { attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors' }
  readonly lightMapUrl = 'https://tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{y}{r}.png';
  readonly darkMapUrl = 'https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.png';
  readonly indonesiaLat = -0.7893;
  readonly indonesiaLong = 113.9213;
  readonly initialZoomLevel = 6;
  readonly maxZoom = 20;
 
  @Input() selectedBrand: number;
  map: L.Map;
  baseMaps = {};
  overlayMaps = {};
  treeCoverLayers: TileUrl[];

  private mapFeatures: Mill[];

  /**
  * Initializes a Leaflet.js map and assigns it either one of two base layers.
  */
  private initMap(): void {
    let lightBaseLayer = L.tileLayer(this.lightMapUrl, this.attribution);
    let darkBaseLayer = L.tileLayer(this.darkMapUrl, this.attribution);
    this.baseMaps = { "Light": lightBaseLayer, "Dark": darkBaseLayer };

    this.map = L.map("map-id", {
      center: new L.LatLng(this.indonesiaLat, this.indonesiaLong),
      zoom: this.initialZoomLevel,
      layers: [lightBaseLayer]
    }); 
  }

  /**
  * Calls the API service for treecover and treecover loss tile set 
  * generated by Google Earth Engine and the adds those tile sets to the map.
  */
  private async addTreeCoverLayers(): Promise<void> {
    let tileUrls = await this.apiService.getTileUrls();
    let treeLossLayers = [];

    tileUrls.forEach(t => {
      let tileLossLayer = L.tileLayer(t.tileUrl, this.attribution);
      if(t.tileSetName == "treecover2000"){
        this.overlayMaps["Treecover 2000"] = tileLossLayer;
      }
      else {
        treeLossLayers.push(tileLossLayer);
      }
    });

    let treelossGroup = L.layerGroup(treeLossLayers);
    this.overlayMaps["Treecover Loss"] = treelossGroup;

    this.overlayMaps["Treecover 2000"].addTo(this.map);
    //this.overlayMaps["Treecover Loss"].addTo(this.map);
  }

  /**
  * Retrieves mills using the API service and adds them as markers to the map.
  * Note: Mills are returned as a dictionary with object ids as keys.
  */
  private async addMillLayer(): Promise<void> {
    let mills = await this.apiService.getMills();
    this.mapFeatures = mills;
    let markers = [];
    let radiiLayer = L.geoJSON(null, { style: this.getMillStyleObject });

    Object.keys(mills).forEach(key => {
      let mill = mills[key];
      let millProps = mill.properties;
      let marker = L.marker(
          [millProps.latitude, millProps.longitude], 
          {icon: this.styleMillMarker(mill)}
        )
        .bindPopup(`
          <div>
            <h3>
              ${millProps.mill_name}<br/>
              <span style="color:grey;">
                ${millProps.sub_state.toUpperCase()}, ${millProps.state.toUpperCase()}
              </span>
            </h3>
          <div>
        `);

        markers.push(marker);
        radiiLayer.addData(mill);
      });

      let markerLayer = L.layerGroup(markers);
      radiiLayer.addTo(this.map);
      markerLayer.addTo(this.map);
      this.overlayMaps["AllMills"] = markerLayer;
      this.overlayMaps["AllMillPolygons"] = radiiLayer;
  }

  /**
  * Returns a style object for a mill based on relative score.
  */
  private getMillStyleObject(feature): object{
    let score = feature.properties.relative_score
    if (score <= -1){
      return {color: "#F11722", fillColor:"#F11722", opacity: 0.2};
    }
    else if (score > -1 && score <= -0.5){
      return {color: "#F55B62", fillColor:"#F55B62", opacity: 0.2};
    }
    else if (score > -0.5 && score <= 0){
      return {color: "#F11722", fillColor:"#F11722", opacity: 0.2};
    }
    else if (score > 0 && score <= 0.5){
      return {color: "#F98E94", fillColor:"#F98E94", opacity: 0.2};
    }
    else if (score > 0.5 && score <= 1){
      return {color: "#F8B44D", fillColor:"#F8B44D", opacity: 0.2};
    }
    else {
      return {color: "#F8ED4D", fillColor:"#F8ED4D", opacity: 0.2};
    }
  }

  /**
  * Builds a custom HTML/CSS-only icon for a mill marker.
  */
  private styleMillMarker(mill): L.DivIcon{
    let style = this.getMillStyleObject(mill);

    let markerHtmlStyles = `
      background-color: ${style["fillColor"]};
      width: 2rem;
      height: 2rem;
      display: block;
      left: -1.5rem;
      top: -1.5rem;
      position: relative;
      border-radius: 3rem 3rem 0;
      transform: rotate(45deg);
      box-shadow: inset 11px 5px 13px 0px rgba(0,0,0,0.48)`
      //border: 1px solid #131200`

    return new L.DivIcon({
      className: "my-custom-pin",
      iconAnchor: [0, 24],
      popupAnchor: [0, -36],
      html: `<span style="${markerHtmlStyles}" />`
    })
  }

  /**
  * Filters mill markers displayed on the map by brand.
  */
  private filterMills(brandId: number): void{

    // Retrieve filtered marker layer and remove if exists
    if(this.overlayMaps.hasOwnProperty("Filtered Markers")){
      let filteredMarkerLayer = this.overlayMaps["Filtered Markers"];
      filteredMarkerLayer.removeFrom(this.map);
      delete this.overlayMaps["Filtered Markers"];
    }

    // Retrieve filtered polygon layer and remove if exists
    if(this.overlayMaps.hasOwnProperty("Filtered Polygons")){
      let filteredPolygonLayer = this.overlayMaps["Filtered Polygons"];
      filteredPolygonLayer.removeFrom(this.map);
      delete this.overlayMaps["Filtered Polygons"];
    }

    // Retrieve layers holding all mills and polygons
    let allMills = this.overlayMaps["AllMills"];
    let allPolygons = this.overlayMaps["AllMillPolygons"]

    if (brandId == null){
      allPolygons.addTo(this.map);
      allMills.addTo(this.map);
      return;
    }

    // Remove layers from map
    allMills.removeFrom(this.map);
    allPolygons.removeFrom(this.map);

    // Generate new layers that filter by consumer brand
    let markers = []
    let radiiLayer = L.geoJSON(null, { style: this.getMillStyleObject });
    Object.values(this.mapFeatures).forEach(mill => {
      let props = mill.properties;

      if(props.consumer_brand_id == brandId){
        let marker = L.marker(
          [props.latitude, props.longitude], 
          {icon: this.styleMillMarker(mill)}
        )
        .bindPopup(`
          <div>
            <h3>
              ${props.mill_name}<br/>
              <span style="color:grey;">
                ${props.sub_state.toUpperCase()}, ${props.state.toUpperCase()}
              </span>
            </h3>
          <div>
        `);

        markers.push(marker);
        radiiLayer.addData(<any>mill);
      }
    });

    // Add new layers to map
    radiiLayer.addTo(this.map);
    let markerLayer = L.layerGroup(markers);
    markerLayer.addTo(this.map);
    this.overlayMaps["Filtered Markers"] = markerLayer;
    this.overlayMaps["Filtered Polygons"] = radiiLayer;
  }

  constructor(private apiService: ApiService) {}

  ngAfterViewInit(): void {
    this.initMap();
    this.addTreeCoverLayers();
    this.addMillLayer();
    L.control.layers(this.baseMaps).addTo(this.map);
  }

  ngOnChanges(changes: SimpleChanges) {      
    this.filterMills(changes.selectedBrand.currentValue);
  }
}
