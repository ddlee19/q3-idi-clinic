import { AfterViewInit, Component, Input, SimpleChanges } from '@angular/core';
import { ApiService } from '../../services/api.service'
import { TileUrl } from '../../interfaces/tile-urls.interface'
import { Mill } from '../../interfaces/mill.interface';
import * as L from 'leaflet';

@Component({
  selector: 'app-map',
  templateUrl: './map.component.html',
  styleUrls: ['./map.component.css']
})
export class MapComponent implements AfterViewInit  {
  readonly attribution = { attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors' }
  readonly lightMapUrl = 'https://tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{y}{r}.png';
  readonly darkMapUrl = 'https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.png';
  readonly indonesiaLat = -0.7893;
  readonly indonesiaLong = 113.9213;
  readonly initialZoomLevel = 6;
  readonly maxZoom = 20;
 
  @Input() selectedBrand: number;
  map: L.Map;
  baseMaps = {};
  overlayMaps = {};
  treeCoverLayers: TileUrl[];

  private millFeatures: Mill[];

  /**
  * Initializes a Leaflet.js map and assigns it either one of two base layers.
  */
  private initMap(): void {
    let lightBaseLayer = L.tileLayer(this.lightMapUrl, this.attribution);
    let darkBaseLayer = L.tileLayer(this.darkMapUrl, this.attribution);
    this.baseMaps = { "Light": lightBaseLayer, "Dark": darkBaseLayer };

    this.map = L.map("map-id", {
      center: new L.LatLng(this.indonesiaLat, this.indonesiaLong),
      zoom: this.initialZoomLevel,
      layers: [lightBaseLayer]
    }); 
  }

  /**
  * Calls the API service for treecover and treecover loss tile set 
  * generated by Google Earth Engine and then adds those tile sets to the map.
  */
  private async addTreeCoverLayers(): Promise<void> {
    let tileUrls = await this.apiService.getTileUrls();
    let treeLossLayers = [];

    tileUrls.forEach(t => {
      let tileLossLayer = L.tileLayer(t.tileUrl, this.attribution);
      if(t.tileSetName == "treecover2000"){
        this.overlayMaps["Treecover 2000"] = tileLossLayer;
      }
      else {
        treeLossLayers.push(tileLossLayer);
      }
    });

    let treelossGroup = L.layerGroup(treeLossLayers);
    this.overlayMaps["Treecover Loss"] = treelossGroup;

    this.overlayMaps["Treecover 2000"].addTo(this.map);
    //this.overlayMaps["Treecover Loss"].addTo(this.map);
  }

  /**
  * Retrieves mills using the API service and adds them as markers to the map.
  * Note: Mills are returned as a dictionary with object ids as keys.
  */
  private async addMillLayer(): Promise<void> {
    let millFeatureCollection = await this.apiService.getMills();
    this.millFeatures = millFeatureCollection.features;
    let markers = [];
    let radiiLayer = L.geoJSON(null, { style: this.getMillStyleObject });

    this.millFeatures.forEach(m => {
      let mill = m.properties;
      let marker = L.marker(
          [mill.latitude, mill.longitude], 
          {icon: this.styleMillMarker(m)}
        )
        .bindPopup(`
          <div>
            <h4>
              ${mill.mill_name}<br/>
              <span style="color:grey;">
                ${mill.sub_state.toUpperCase()}, ${mill.state.toUpperCase()}
              </span><br/>
              Current Risk Score: ${mill.risk_score_current}
            </h4>
          <div>
        `);

        markers.push(marker);
        radiiLayer.addData(<any>m);
      });

      let markerLayer = L.layerGroup(markers);
      radiiLayer.addTo(this.map);
      markerLayer.addTo(this.map);
      this.overlayMaps["AllMills"] = markerLayer;
      this.overlayMaps["AllMillPolygons"] = radiiLayer;
  }

  /**
  * Returns a style object for a mill based on relative score.
  */
  private getMillStyleObject(millFeature): object{
    let score = millFeature.properties.risk_score_current

    if (score == 1) {
      return {color: "#ffc743", fillColor:"#ffc743", opacity: 0.2};
    }
    else if (score == 2){
      return {color: "#fb7337", fillColor:"#fb7337", opacity: 0.2};
    }
    else if (score == 3){
      return {color: "#f60b28", fillColor:"#f60b28", opacity: 0.2};
    }
    else if (score == 4){
      return {color: "#95081b", fillColor:"#95081b", opacity: 0.2};
    }
    else {
      return {color: "#34040d", fillColor:"#34040d", opacity: 0.2};
    }
  }

  /**
  * Builds a custom HTML/CSS-only icon for a mill marker.
  */
  private styleMillMarker(m): L.DivIcon{
    let style = this.getMillStyleObject(m);

    let markerHtmlStyles = `
      background-color: ${style["fillColor"]};
      width: 2rem;
      height: 2rem;
      display: block;
      left: -1.5rem;
      top: -1.5rem;
      position: relative;
      border-radius: 3rem 3rem 0;
      transform: rotate(45deg);
      box-shadow: inset 11px 5px 13px 0px rgba(0,0,0,0.48)`

    return new L.DivIcon({
      className: "my-custom-pin",
      iconAnchor: [0, 0],
      popupAnchor: [0, -36],
      html: `<span style="${markerHtmlStyles}" />`
    })
  }

  /**
  * Filters mill markers displayed on the map by brand.
  */
  private filterMills(brandName: string): void{

    // Retrieve filtered marker layer and remove if exists
    if(this.overlayMaps.hasOwnProperty("Filtered Markers")){
      let filteredMarkerLayer = this.overlayMaps["Filtered Markers"];
      filteredMarkerLayer.removeFrom(this.map);
      delete this.overlayMaps["Filtered Markers"];
    }

    // Retrieve filtered polygon layer and remove if exists
    if(this.overlayMaps.hasOwnProperty("Filtered Polygons")){
      let filteredPolygonLayer = this.overlayMaps["Filtered Polygons"];
      filteredPolygonLayer.removeFrom(this.map);
      delete this.overlayMaps["Filtered Polygons"];
    }

    // Retrieve layers holding all mills and polygons
    let allMills = this.overlayMaps["AllMills"];
    let allPolygons = this.overlayMaps["AllMillPolygons"]

    // If no filters are set, add all polygons and mills by default and return
    if (brandName == null){
      allPolygons.addTo(this.map);
      allMills.addTo(this.map);
      return;
    }

    // Otherwise, remove layers from map
    allMills.removeFrom(this.map);
    allPolygons.removeFrom(this.map);

    // Generate new layers that filter by consumer brand
    let markers = []
    let radiiLayer = L.geoJSON(null, { style: this.getMillStyleObject });
    Object.values(this.millFeatures).forEach(mill => {
      let props = mill.properties;


      if(props.brand !== undefined && brandName in props.brand){
        console.log("In here")
        let marker = L.marker(
          [props.latitude, props.longitude], 
          {icon: this.styleMillMarker(mill)}
        )
        .bindPopup(`
          <div>
            <h3>
              ${props.mill_name}<br/>
              <span style="color:grey;">
                ${props.district.toUpperCase()}, ${props.province.toUpperCase()}
              </span>
            </h3>
          <div>
        `);

        markers.push(marker);
        radiiLayer.addData(<any>mill);
      }
    });

    // Add new layers to map
    radiiLayer.addTo(this.map);
    let markerLayer = L.layerGroup(markers);
    markerLayer.addTo(this.map);
    this.overlayMaps["Filtered Markers"] = markerLayer;
    this.overlayMaps["Filtered Polygons"] = radiiLayer;
  }

  constructor(private apiService: ApiService) {}

  ngAfterViewInit(): void {
    this.initMap();
    this.addTreeCoverLayers();
    this.addMillLayer();
  }

  ngOnChanges(changes: SimpleChanges) { 
    console.log(changes.selectedBrand.currentValue) ;   
    this.filterMills(changes.selectedBrand.currentValue);
  }
}
